# Bin

Membrane's Bin is a container for elements. Its main purpose is to create a bigger building block consisting of elements, which are often used together in order to 

Membrane's bin, similarly to a pipeline, is a containers for elements. However, unlike pipelines bin can be placed and linked within pipelines. Although bin is a separate Membrane entity, it can be perceived as an element from pipeline's perspective. Bins can also be nested within one another.
As you can see, this allows for creating reusable groups of elements.
Bin also has another advantage - it manages its children, for instance by dynamically spawning or replacing them as the stream changes.

# Enclosing pipeline elements inside a bin

As you can see, we have `Source` -> `Ordering Buffer` -> `Depayloader` chain, which is duplicated.
![Pipeline scheme](../basic_pipeline/assets/images/basic_pipeline.png) <br>

We can encapsulate these elements inside `Bin`. Just like with a pipeline, we have to define bin's children and links between them.

```Elixir
defmodule Basic.Bin do
  use Membrane.Bin

  def_output_pad :output,
    demand_unit: :buffers,
    caps: {Basic.Formats.Frame, encoding: :utf8}

  @impl true
  def handle_init(_opts) do
    children = %{
      input: %Basic.Elements.Source{location: "input.A.txt"},
      ordering_buffer: Basic.Elements.OrderingBuffer,
      depayloader: %Basic.Elements.Depayloader{packets_per_frame: 4}
    }

    links = [
      link(:input) |> to(:ordering_buffer) |> to(:depayloader) |> to_bin_output(:output)
    ]

    spec = %ParentSpec{children: children, links: links}

    {{:ok, spec: spec}, %{}}
  end
end
```

First thing you may notice, is that unlike with the pipeline we are defining output pads. This is because the bin has to send its data to `Mixer`.
To send data from the bin we also have to link its last element with the output pads. This takes place when defining links - the last link in the bin is between `depayloader` and bin's output pads.

Although the bin is already functional, to make it reusable we have to parametrize it with the input filename. That's why we will define options for the bin, which we will use for the `source` element.

```Elixir
defmodule Basic.Bin do
  use Membrane.Bin

  ...

  def_options input_filename: [
                type: :string,
                description: "Input file for conversation."
              ]

  @impl true
  def handle_init(options) do
    children = %{
      input: %Basic.Elements.Source{location: options.input_filename},
      ...
    }
    ...
  end
end
```

# Modifying pipeline using bin

Using the bin we created, we can replace the elements in pipeline.

```Elixir
defmodule Basic.Pipeline do
  @moduledoc """
  A module providing the pipeline, which aggregates and links the elements.
  """
  use Membrane.Pipeline

  @impl true
  def handle_init(_opts) do
    children = %{
      bin1: %Basic.Bin{input_filename: "input.A.txt"},
      bin2: %Basic.Bin{input_filename: "input.B.txt"},
      mixer: Basic.Elements.Mixer,
      output: %Basic.Elements.Sink{location: "output.txt"}
    }

    links = [
      link(:bin1) |> via_in(:first_input) |> to(:mixer),
      link(:bin2) |> via_in(:second_input) |> to(:mixer),
      link(:mixer) |> to(:output)
    ]

    spec = %ParentSpec{children: children, links: links}

    {{:ok, spec: spec}, %{}}
  end
end
```

The pipeline became much simpler.

Combining usage of bin and [dynamic pads](/basic_pipeline_extension/02.0_DynamicPads) will result in even cleaner and more scalable solution.